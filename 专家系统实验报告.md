# 专家系统实验报告

- ## 静态知识的表示与存储

  - **存储：**静态的知识（规则）存储在文本文件rules.txt（知识库）中，每一次进行推理都要将规则库读入到数据结构class Rule中去，这样可以方便地将修改作用于txt文件，而不必变动代码。

  - **增添：**该系统还提供了增添新规则的功能(rule_editor.py)，在这个模块中，用户在界面中分别输入三个命题。三个部分会被填入相应格式写入知识库。

  - **构成：**每条rule用{ }括起，{ }中有构成规则的if、then、description三部分。

    例如：

  ```python
  {
  IF: ['3 closure lines']
  THEN: 'the shape is triangle'
  DESCRIPTION: 'triangle'
  }
  ```

  

- ## 动态事实的输入转化

  - **过程：**cv_handler2.py中，通过opencv库对图片进行预处理，读取到图片所包含的信息（一组基本事实），存入文本文件facts.txt，即为该图片对应生成的数据库。

  

  - **实现：**class fact中的函数，从端点、边、角三个方面入手，得到图中每一个图形（以counter编号）的信息：

    - **端点：**

      坐标值->判断相同关系

      相同关系->判断closure的条件

    - **边：**

      长度值->判断相等关系

      相等关系

      平行关系

      closure关系

    - **角：**

      角度值->判断平行关系、特殊角

      出现锐角/直角/钝角及其数量

    值得注意的是：该过程中涉及到的判断都为近似判断，需规定允许误差范围。

  - **构成：**最终，在facts.txt中罗列出的每一条信息都为完整的（端点坐标，边长，角度）信息。组织形式为：

    ```
    Contour #i
    {
    --About Lines-- #x lines
    <
    #y lines are equal/lines are all equal
    #y条信息
    #z closure lines
    #z条信息
    >
    --About Angles--
    <
    #j angle is right/acute/obtuse angle
    #j条信息
    #k pairs of parallel line
    ```

    



- ## 推理过程与解释过程

  - **推理过程：**(inference_engine.py) 将数据库(facts.txt)中的断言读入作为推理的前项；并且读入知识库(rule.txt)中的规则，通过正则表达式分别识别出该规则的if、then、description部分。接着使用后向链接推理的方法，根据rule的后项来搜索在facts中是否有能够满足它前项，当目的满足时，该次检测成功、输出相关信息。

  - **推理过程的实现：**

    两个主要功能的实现为

    - set_up_engine函数——engine的读入处理：

      ```python
      def setup_engine(image_source):
      
      /*  实例化生成概要事实  */
          handler = Handler(image_source)
          handler.generate_contour_dict()
          generator = FactGenerator(handler.contour_dict)
          generator.generate_fact()
          
      /*  读入规则   */
          r = read_rules('rules.txt')
          
      /*  调用Engine()做匹配  */
          e = Engine(r, generator.handled_facts)
          return e
      ```

      

    - Engine类——前后项的匹配：

      1. 在类中，为方便函数的实现，先用python的list构建了stack，并封装pop、push、top、empty基本功能；

      2. *(__hit_consequent函数__)* 对一个目标的consequence在规则库中寻找后项与它一致的规则，将所有找到的规则都append到 hit_rules[]列表中去；

         ```python
         def __hit_consequent__(self, cons, contour_index):
         hit = False
         for rule in self.rule_library:
             if cons == getattr(rule, 'consequent'):
                 hit = True
                 self.hit_rules['Contour' + str(contour_index)].append(rule)
                 ants = getattr(rule, 'antecedent')
                 for ant in ants:
                     if not self.__match_facts__(ant, contour_index):
                         self.push_condition_stack(ant)
                 break
         return hit
         ```

         

      3. *(__match_facts函数__)* 每找到一条这样的规则，用它的前项在facts中搜索是否有匹配项，由于前项可能有多条，且前项间为“与”连接，只要有任一前项匹配失败，就代表这条规则匹配失败。

         若成功，将匹配成功的fact append到matched_facts[]列表；

         ```python
         def __match_facts__(self, ant, contour_index):
                 facts = self.fact_library['Contour' + str(contour_index)]
                 matched = False
                 for fact in facts.line_facts:
                     if ant == fact.fact:
                         matched = True
                         self.matched_facts['Contour' + str(contour_index)].append(fact)
                         return matched
                 for fact in facts.angle_facts:
                     if ant == fact.fact:
                         matched = True
                         self.matched_facts['Contour' + str(contour_index)].append(fact)
                         return matched
                 return matched
         ```

         

      4. *(__hit_consequent函数__)* 若失败，将匹配失败的规则push到一个栈 condition_stack中去，留待处理；

      5. *(__run函数__)*对栈中的每一条规则，将后项作为consequent再做一次step2-4的匹配，若仍未匹配成功，结论失败。

         ```python
         def run(self, contour_index):
                 self.matched_facts['Contour' + str(contour_index)] = []
                 self.hit_rules['Contour' + str(contour_index)] = []
                 found = True
                 while self.condition_stack:
                     # test
                     # print(self.condition_stack)
                     cons = self.pop_condition_stack()
                     if not self.__hit_consequent__(cons, contour_index):
                         found = False
                         break
                 self.condition_stack = [self.target]
                 if found:
                     return 'SUCCESS: Find Required Shape in Contour%d' % contour_index
                 else:
                     self.matched_facts['Contour' + str(contour_index)] = []
                     self.hit_rules['Contour' + str(contour_index)] = []
                     return 'ERROR: No Sufficient Facts in Contour%d' % contour_index
         ```

  - **解释过程：**以图形界面与结果信息相结合的方式，呈现每一次诊断结果。并且设置了选项供用户添加规则。
  - **解释过程的实现：**图形界面的制作在main_frame.py中，需输出的结果信息的产生集成在推理过程中。

------

- #### 一些想法：

  - 规则的添加是否可以自动完成呢？比如在匹配搜索的过程中运用到栈并最终成功，说明有新的规则产生。此时可以程序主动将规则写入知识库，完成知识库的更新。
  - 反向链接可以多次根据栈中内容做匹配，该系统只做了一次，可能会错过潜在的匹配机会、潜在知识；建议在push之前就对第一次不匹配的规则做一个打分，如对所有的的前项都做匹配，而非遇到不匹配就break，可以按照前项中匹配的百分比决定将哪一条规则反向迭代迭代，以及迭代的次数。
  - 反向迭代直至栈空可行吗？不可以。容易陷入死循环。
  - 用户添加的规则是否会与已有规则冲突？不会；但存在情况（在前面两点的条件下）用户输入的规则会诱发程序进入死循环。比如已有规则A,C->B,用户输入B,D->A   E,F->C......若系统从B开始反向链接推理，而这些条件恰好都不在facts中。取决于打分函数的设计。